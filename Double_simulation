from roboticstoolbox import ERobot
from roboticstoolbox.backends.PyPlot import PyPlot
from spatialmath import SE3
import numpy as np
import time

# Load the first robot model
robot1 = ERobot.URDF(r"C:\Users\Asbjo\Desktop\kinova_assembly_description\urdf\kinova_assembly.urdf")

# Load the second robot model
robot2 = ERobot.URDF(r"C:\Users\Asbjo\Desktop\j5_assembly_description\urdf\j5_assembly.urdf")

# Initialize separate PyPlot backends for each robot
backend1 = PyPlot()
backend2 = PyPlot()

backend1.launch()
backend2.launch()

# Add the robots to their respective backends
backend1.add(robot1)
backend2.add(robot2)

# Define Cartesian goal poses for each robot
goal_poses_robot1 = [
    SE3(-1.466, 0.0, -1.583) * SE3.Rz(0),         # Pose 1: Position + no rotation
    SE3(-0.552, 0.0, -1.583) * SE3.Rx(np.pi / 4), # Pose 2: Position + rotation about X
]

goal_poses_robot2 = [
    SE3(-1.2, 0.5, -1.4) * SE3.Rz(0),             # Pose 1: Position + no rotation
    SE3(-0.7, -0.3, -1.2) * SE3.Ry(np.pi / 6),    # Pose 2: Position + rotation about Y
]

# Function to plot goal poses on a given backend
def plot_goal_poses(backend, goal_poses):
    for pose in goal_poses:
        position = pose.t  # Extract translational part (x, y, z)
        orientation = pose.R  # Extract rotational part (3x3 matrix)
        
        # Plot the position as a point
        backend.ax.scatter(position[0], position[1], position[2], color='red', s=50, label='Goal Pose')
        
        # Plot a small coordinate frame for the orientation
        scale = 0.1  # Scale of the coordinate frame
        x_axis = position + orientation[:, 0] * scale  # X-axis of the frame
        y_axis = position + orientation[:, 1] * scale  # Y-axis of the frame
        z_axis = position + orientation[:, 2] * scale  # Z-axis of the frame
        
        # Plot axes
        backend.ax.plot([position[0], x_axis[0]], [position[1], x_axis[1]], [position[2], x_axis[2]], color='red')
        backend.ax.plot([position[0], y_axis[0]], [position[1], y_axis[1]], [position[2], y_axis[2]], color='green')
        backend.ax.plot([position[0], z_axis[0]], [position[1], z_axis[1]], [position[2], z_axis[2]], color='blue')

    backend.ax.legend(["Goal Poses"])

# Plot goal poses for both robots
plot_goal_poses(backend1, goal_poses_robot1)
plot_goal_poses(backend2, goal_poses_robot2)

# Pause to examine the visualizations
input("Robots and goal poses visualized. Press Enter to start the motion...")

# Solve inverse kinematics and move robots to their goal poses
def solve_and_move(robot, backend, goal_poses):
    goal_configs = []
    for idx, pose in enumerate(goal_poses):
        ik_solution = robot.ikine_LM(pose)  # Solve IK
        if ik_solution.success:
            goal_configs.append(ik_solution.q)  # Append the joint configuration
        else:
            print(f"Failed to solve IK for pose {idx + 1}: {pose}")
            exit()
    
    # Move the robot through the goal configurations
    for i in range(len(goal_configs)):
        q_goal = goal_configs[i]
        
        # If this is not the first pose, interpolate from the previous one
        if i > 0:
            q_start = goal_configs[i - 1]
            joint_trajectory = np.linspace(q_start, q_goal, 50)
            for q in joint_trajectory:
                robot.q = q  # Update the robot's joint configuration
                backend.step()  # Update the visualization
                time.sleep(0.05)  # Add a small delay for smooth animation
        else:
            # For the first pose, just set the configuration
            robot.q = q_goal
            backend.step()
        
        # Pause at the goal pose
        print(f"Robot reached goal pose {i + 1}.")
        input("Press Enter to move to the next goal pose...")

# Run the motion for both robots
solve_and_move(robot1, backend1, goal_poses_robot1)
solve_and_move(robot2, backend2, goal_poses_robot2)

# Hold both visualizations open
backend1.hold()
backend2.hold()
